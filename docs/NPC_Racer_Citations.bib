@misc{AlgorithmsGraphSearch,
  title = {Algorithms - {{A}}* Graph Search Time-Complexity - {{Computer Science Stack Exchange}}},
  howpublished = {https://cs.stackexchange.com/questions/56176/a-graph-search-time-complexity},
  file = {C\:\\Users\\Brendan\\Zotero\\storage\\2U96ET5Q\\a-graph-search-time-complexity.html}
}

@article{AntColonyOptimization2022,
  title = {Ant Colony Optimization Algorithms},
  year = {2022},
  month = sep,
  journal = {Wikipedia},
  abstract = {In computer science and operations research, the ant colony optimization algorithm (ACO) is a probabilistic technique for solving computational problems which can be reduced to finding good paths through graphs. Artificial ants stand for multi-agent methods inspired by the behavior of real ants.  The pheromone-based communication of biological ants is often the predominant paradigm used.   Combinations of artificial ants and local search algorithms have become a method of choice for numerous optimization tasks involving some sort of graph, e.g., vehicle routing and internet routing. As an example, ant colony optimization  is a class of optimization algorithms modeled on the actions of an ant colony.  Artificial 'ants' (e.g. simulation agents) locate optimal solutions by moving through a parameter space representing all possible solutions.  Real ants lay down pheromones directing each other to resources while exploring their environment.  The simulated 'ants' similarly record their positions and the quality of their solutions, so that in later simulation iterations more ants locate better solutions.  One variation on this approach is the bees algorithm, which is more analogous to the foraging patterns of the honey bee, another social insect. This algorithm is a member of the ant colony algorithms family, in swarm intelligence methods, and it constitutes some metaheuristic optimizations. Initially proposed by Marco Dorigo in 1992 in his PhD thesis, the first algorithm was aiming to search for an optimal path in a graph, based on the behavior of ants seeking a path between their colony and a source of food. The original idea has since diversified to solve a wider class of numerical problems, and as a result, several problems have emerged, drawing on various aspects of the behavior of ants. From a broader perspective, ACO performs a model-based search and shares some similarities with estimation of distribution algorithms.},
  copyright = {Creative Commons Attribution-ShareAlike License},
  langid = {english},
  annotation = {Page Version ID: 1112865549},
  file = {C\:\\Users\\Brendan\\Zotero\\storage\\DWNUB6FG\\Ant_colony_optimization_algorithms.html}
}

@article{BeesAlgorithm2022,
  title = {Bees Algorithm},
  year = {2022},
  month = jul,
  journal = {Wikipedia},
  abstract = {In computer science and operations research, the bees algorithm is a population-based search algorithm which was developed by Pham, Ghanbarzadeh et al. in 2005. It mimics the food foraging behaviour of honey bee colonies. In its basic version the algorithm performs a kind of neighbourhood search combined with global search, and can be used for both combinatorial optimization and continuous optimization. The only condition for the application of the bees algorithm is that some measure of distance between the solutions is defined. The effectiveness and specific abilities of the bees algorithm have been proven in a number of studies.},
  copyright = {Creative Commons Attribution-ShareAlike License},
  langid = {english},
  annotation = {Page Version ID: 1098932820},
  file = {C\:\\Users\\Brendan\\Zotero\\storage\\9CLXM44L\\Bees_algorithm.html}
}

@misc{CitationMatrixMovie,
  title = {Citation: {{The Matrix}} [{{Movie}}] - {{BibGuru Guides}}},
  shorttitle = {Citation},
  journal = {Bibguru},
  abstract = {Citations for The Matrix: Hundreds of citation styles including \ding{51} APA \ding{51} MLA \ding{51} Chicago},
  howpublished = {https://www.bibguru.com/m/how-to-cite-the-matrix/},
  langid = {english},
  file = {C\:\\Users\\Brendan\\Zotero\\storage\\Z882MD8J\\how-to-cite-the-matrix.html}
}

@misc{codeaestheticNamingThingsCode2022,
  title = {Naming {{Things}} in {{Code}}},
  author = {{CodeAesthetic}},
  year = {2022},
  month = nov,
  abstract = {It's hard to come up with good names in code, but its also easy to get wrong. By looking at some examples, we can get 80\% of the way there. Access to code examples, discord, song names and more at https://www.patreon.com/codeaesthetic 0:00 Introduction 0:31 Variables with a single letter 1:08 Never Abbreviate 2:06 Types in your names 2:36 Units in your variable names 3:37 Types in your types 4:30 Naming a class "Base" or "Abstract" 5:45 Don't name code "Utils" 7:09 Conclusion   \#softwaredesign  \#code \#programming}
}

@misc{computerphileDijkstraAlgorithmComputerphile2017,
  title = {Dijkstra's {{Algorithm}} - {{Computerphile}}},
  author = {{Computerphile}},
  year = {2017},
  month = jan,
  abstract = {Dijkstra's Algorithm finds the shortest path between two points. Dr Mike Pound explains how it works. How Sat Nav Works: https://youtu.be/EUrU1y5is3Y  Slow Loris Attack: https://youtu.be/XiFkyR35v2Y  http://www.facebook.com/computerphile https://twitter.com/computer\_phile This video was filmed and edited by Sean Riley. Computer Science at the University of Nottingham: http://bit.ly/nottscomputer Computerphile is a sister project to Brady Haran's Numberphile. More at http://www.bradyharan.com}
}

@misc{computerphileMazeSolvingComputerphile2017,
  title = {Maze {{Solving}} - {{Computerphile}}},
  author = {{Computerphile}},
  year = {2017},
  month = feb,
  abstract = {Putting search algorithms into practice. Dr Mike Pound reveals he likes nothing more in his spare time, than sitting in front of the TV coding. EXTRA BITS: https://youtu.be/kF7KlThoT9w Mike's Code: http://bit.ly/MikesMarvellousMazes  http://www.facebook.com/computerphile https://twitter.com/computer\_phile This video was filmed and edited by Sean Riley. Computer Science at the University of Nottingham: http://bit.ly/nottscomputer Computerphile is a sister project to Brady Haran's Numberphile. More at http://www.bradyharan.com},
  keywords = {TORead}
}

@misc{computerphileStarSearchAlgorithm2017,
  title = {A* ({{A Star}}) {{Search Algorithm}} - {{Computerphile}}},
  author = {{Computerphile}},
  year = {2017},
  month = feb,
  abstract = {Improving on Dijkstra, A* takes into account the direction of your goal. Dr Mike Pound explains.  Correction: At 8min 38secs 'D' should, of course, be 14 not 12. This does not change the result. Dijkstra's Algorithm: https://youtu.be/GazC3A4OQTE  How GPS Works: https://youtu.be/EUrU1y5is3Y http://www.facebook.com/computerphile https://twitter.com/computer\_phile This video was filmed and edited by Sean Riley. Computer Science at the University of Nottingham: http://bit.ly/nottscomputer Computerphile is a sister project to Brady Haran's Numberphile. More at http://www.bradyharan.com}
}

@article{DijkstraAlgorithm2022,
  title = {Dijkstra's Algorithm},
  year = {2022},
  month = dec,
  journal = {Wikipedia},
  abstract = {Dijkstra's algorithm ( DYKE-str{$\Elzschwa$}z) is an algorithm for finding the shortest paths between nodes in a graph, which may represent, for example, road networks.  It was conceived by computer scientist Edsger W. Dijkstra in 1956 and published three years later.The algorithm exists in many variants. Dijkstra's original algorithm found the shortest path between two given nodes, but a more common variant fixes a single node as the "source" node and finds shortest paths from the source to all other nodes in the graph, producing a shortest-path tree. For a given source node in the graph, the algorithm finds the shortest path between that node and every other.:{$\mkern1mu$}196\textendash 206{$\mkern1mu$} It can also be used for finding the shortest paths from a single node to a single destination node by stopping the algorithm once the shortest path to the destination node has been determined. For example, if the nodes of the graph represent cities and edge path costs represent driving distances between pairs of cities connected by a direct road (for simplicity, ignore red lights, stop signs, toll roads and other obstructions), Dijkstra's algorithm can be used to find the shortest route between one city and all other cities. A widely used application of shortest path algorithms is network routing protocols, most notably IS-IS (Intermediate System to Intermediate System) and OSPF (Open Shortest Path First). It is also employed as a subroutine in other algorithms such as Johnson's. The Dijkstra algorithm uses labels that are positive integers or real numbers, which are totally ordered.  It can be generalized to use any labels that are partially ordered, provided the subsequent labels (a subsequent label is produced when traversing an edge) are monotonically non-decreasing.  This generalization is called the generic Dijkstra shortest-path algorithm.Dijkstra's algorithm uses a data structure for storing and querying partial solutions sorted by distance from the start. While the original algorithm uses a min-priority queue and runs in time                         {$\Theta$}         (         (                    |                  V                    |                  +                    |                  E                    |                  )         log         ‚Å°                    |                  V                    |                  )                 \{\textbackslash displaystyle \textbackslash Theta ((|V|+|E|)\textbackslash log |V|)\}   (where                                    |                  V                    |                          \{\textbackslash displaystyle |V|\}    is the number of nodes and                                    |                  E                    |                          \{\textbackslash displaystyle |E|\}    is the number of edges), it can also be implemented in                         {$\Theta$}         (                    |                  V                                 |                                   2                             )                 \{\textbackslash displaystyle \textbackslash Theta (|V|\^\{2\})\}    using an array. The idea of this algorithm is also given in Leyzorek et al. 1957. Fredman \& Tarjan 1984 propose using a Fibonacci heap min-priority queue to optimize the running time complexity to                         {$\Theta$}         (                    |                  E                    |                  +                    |                  V                    |                  log         ‚Å°                    |                  V                    |                  )                 \{\textbackslash displaystyle \textbackslash Theta (|E|+|V|\textbackslash log |V|)\}   . This is asymptotically the fastest known single-source shortest-path algorithm for arbitrary directed graphs with unbounded non-negative weights. However, specialized cases (such as bounded/integer weights, directed acyclic graphs etc.) can indeed be improved further as detailed in Specialized variants. Additionally, if preprocessing is allowed algorithms such as contraction hierarchies can be up to seven orders of magnitude faster. In some fields, artificial intelligence in particular, Dijkstra's algorithm or a variant of it is known as uniform cost search and formulated as an instance of the more general idea of best-first search.},
  copyright = {Creative Commons Attribution-ShareAlike License},
  langid = {english},
  annotation = {Page Version ID: 1127202995},
  file = {C\:\\Users\\Brendan\\Zotero\\storage\\JIU3GLS5\\Dijkstra's_algorithm.html}
}

@book{millingtonAIGamesThird2019,
  title = {{{AI}} for {{Games}}, {{Third Edition}}},
  author = {Millington, Ian},
  year = {2019},
  month = mar,
  edition = {3rd edition},
  publisher = {{CRC Press}},
  address = {{Boca Raton}},
  isbn = {978-1-138-48397-2},
  langid = {english}
}

@article{Pathfinding2022,
  title = {Pathfinding},
  year = {2022},
  month = dec,
  journal = {Wikipedia},
  abstract = {Pathfinding or pathing is the plotting, by a computer application, of the shortest route between two points. It is a more practical variant on solving mazes. This field of research is based heavily on Dijkstra's algorithm for finding the shortest path on a weighted graph. Pathfinding is closely related to the shortest path problem, within graph theory, which examines how to identify the path that best meets some criteria (shortest, cheapest, fastest, etc) between two points in a large network.},
  copyright = {Creative Commons Attribution-ShareAlike License},
  langid = {english},
  annotation = {Page Version ID: 1127506752},
  file = {C\:\\Users\\Brendan\\Zotero\\storage\\F236GBKZ\\Pathfinding.html}
}

@article{RogueVideoGame2022,
  title = {{\emph{Rogue}} (Video Game)},
  year = {2022},
  month = dec,
  journal = {Wikipedia},
  abstract = {Rogue (also known as Rogue: Exploring the Dungeons of Doom) is a dungeon crawling video game by Michael Toy and Glenn Wichman with later contributions by Ken Arnold. Rogue was originally developed around 1980 for Unix-based mainframe systems as a freely distributed executable. It was later included in the official Berkeley Software Distribution 4.2 operating system (4.2BSD). Commercial ports of the game for a range of personal computers were made by Toy, Wichman, and Jon Lane under the company A.I. Design and financially supported by the Epyx software publishers. Additional ports to modern systems have been made since by other parties using the game's now-open source code. In Rogue, players control a character as they explore several levels of a dungeon seeking the Amulet of Yendor located in the dungeon's lowest level. The player-character must fend off an array of monsters that roam the dungeons. Along the way, players can collect treasures that can help them offensively or defensively, such as weapons, armor, potions, scrolls, and other magical items. Rogue is turn-based, taking place on a square grid represented in ASCII or other fixed character set, allowing players to have time to determine the best move to survive. Rogue implements permadeath as a design choice to make each action by the player meaningful{$\mkern1mu$}\textemdash{$\mkern1mu$}should one's player-character lose all his health via combat or other means, that player-character is simply dead. The player must then restart with a fresh character as the dead character cannot respawn, or be brought back by reloading from a saved state. Moreover, no game is the same as any previous one, as the dungeon levels, monster encounters, and treasures are procedurally generated for each playthrough. Rogue was inspired by text-based computer games such as the 1971 Star Trek game and Colossal Cave Adventure released in 1976, along with the high fantasy setting from Dungeons \& Dragons. Toy and Wichman, both students at University of California, Santa Cruz, worked together to create their own text-based game but looked to incorporate elements of procedural generation to create a new experience each time the user played the game. Toy later worked at University of California, Berkeley where he met Arnold, the lead developer of the curses programming library that Rogue was dependent on to mimic a graphical display. Arnold helped Toy to optimize the code and incorporate additional features to the game. The commercial ports were inspired when Toy met Lane while working for the Olivetti company, and Toy engaged with Wichman again to help with designing graphics and various ports. Rogue became popular in the 1980s among college students and other computer-savvy users in part due to its inclusion in 4.2BSD. It inspired programmers to develop a number of similar titles such as Hack (1982/1984) and Moria (1983), though as Toy, Wichman, and Arnold had not released the source code at this time, these new games introduced different variations atop Rogue. A long lineage of games grew out from these titles. While Rogue was not the first dungeon-crawling game with procedural generation features, it introduced the subgenre of roguelike RPG procedurally generated dungeon crawlers with Dungeons-and-Dragons-like items (armor, weapons, potions, and magic scrolls) that also had permadeath (permanent death) and an overhead graphical view{$\mkern1mu$}\textemdash{$\mkern1mu$}albeit via ASCII drawings, as opposed to text descriptions in natural language such as in Adventure/Colossal Cave and the original Zork games.},
  copyright = {Creative Commons Attribution-ShareAlike License},
  langid = {english},
  annotation = {Page Version ID: 1126769607},
  file = {C\:\\Users\\Brendan\\Zotero\\storage\\V7JUTIEX\\Rogue_(video_game).html}
}

@article{SearchAlgorithm2022,
  title = {A* Search Algorithm},
  year = {2022},
  month = dec,
  journal = {Wikipedia},
  abstract = {A* (pronounced "A-star") is a graph traversal and path search algorithm, which is used in many fields of computer science due to its completeness, optimality, and optimal efficiency. One major practical drawback is its                         O         (                    b                        d                             )                 \{\textbackslash displaystyle O(b\^\{d\})\}    space complexity, as it stores all generated nodes in memory. Thus, in practical travel-routing systems, it is generally outperformed by algorithms which can pre-process the graph to attain better performance, as well as memory-bounded approaches; however, A* is still the best solution in many cases.Peter Hart, Nils Nilsson and Bertram Raphael of Stanford Research Institute (now SRI International) first published the algorithm in 1968. It can be seen as an extension of Dijkstra's algorithm. A* achieves better performance by using heuristics to guide its search. Compared to Dijkstra's algorithm, the A* algorithm only finds the shortest path from a specified source to a specified goal, and not the shortest-path tree from a specified source to all possible goals. This is a necessary trade-off for using a specific-goal-directed heuristic. For Dijkstra's algorithm, since the entire shortest-path tree is generated, every node is a goal, and there can be no specific-goal-directed heuristic.},
  copyright = {Creative Commons Attribution-ShareAlike License},
  langid = {english},
  annotation = {Page Version ID: 1127312005},
  file = {C\:\\Users\\Brendan\\Zotero\\storage\\W329UFEF\\A_search_algorithm.html}
}

@article{ShortestPathProblem2022,
  title = {Shortest Path Problem},
  year = {2022},
  month = dec,
  journal = {Wikipedia},
  abstract = {In graph theory, the shortest path problem is the problem of finding a path between two vertices (or nodes) in a graph such that the sum of the weights of its constituent edges is minimized. The problem of finding the shortest path between two intersections on a road map may be modeled as a special case of the shortest path problem in graphs, where the vertices correspond to intersections and the edges correspond to road segments, each weighted by the length of the segment.},
  copyright = {Creative Commons Attribution-ShareAlike License},
  langid = {english},
  annotation = {Page Version ID: 1126599032},
  file = {C\:\\Users\\Brendan\\Zotero\\storage\\4KTZHS7B\\Shortest_path_problem.html}
}

@article{TravellingSalesmanProblem2022,
  title = {Travelling Salesman Problem},
  year = {2022},
  month = dec,
  journal = {Wikipedia},
  abstract = {The travelling salesman problem (also called the travelling salesperson problem  or TSP) asks the following question: "Given a list of cities and the distances between each pair of cities, what is the shortest possible route that visits each city exactly once and returns to the origin city?" It is an NP-hard problem in combinatorial optimization, important in theoretical computer science and operations research. The travelling purchaser problem and the vehicle routing problem are both generalizations of TSP. In the theory of computational complexity, the decision version of the TSP (where given a length L, the task is to decide whether the graph has a tour of at most L) belongs to the class of NP-complete problems. Thus, it is possible that the worst-case running time for any algorithm for the TSP increases superpolynomially (but no more than exponentially) with the number of cities. The problem was first formulated in 1930 and is one of the most intensively studied problems in optimization. It is used as a benchmark for many optimization methods. Even though the problem is computationally difficult, many heuristics and exact algorithms are known, so that some instances with tens of thousands of cities can be solved completely and even problems with millions of cities can be approximated within a small fraction of 1\%.The TSP has several applications even in its purest formulation, such as planning, logistics, and the manufacture of microchips. Slightly modified, it appears as a sub-problem in many areas, such as DNA sequencing. In these applications, the concept city represents, for example, customers, soldering points, or DNA fragments, and the concept distance represents travelling times or cost, or a similarity measure between DNA fragments. The TSP also appears in astronomy, as astronomers observing many sources will want to minimize the time spent moving the telescope between the sources; in such problems, the TSP can be embedded inside an optimal control problem. In many applications, additional constraints such as limited resources or time windows may be imposed.},
  copyright = {Creative Commons Attribution-ShareAlike License},
  langid = {english},
  annotation = {Page Version ID: 1128294054},
  file = {C\:\\Users\\Brendan\\Zotero\\storage\\XZJCZUL8\\Travelling_salesman_problem.html}
}
